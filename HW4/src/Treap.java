import java.util.Random;
import java.util.Stack;

/**
 * @author Jerry Cheng
 * I pledge my honor that I have abided by the Stevens Honor System.
 */

public class Treap<E extends Comparable<E>> {
    private static class Node<E> {

        public E data;
        public int priority;
        public Node<E> left;
        public Node<E> right;

        // Constructors

        /**
         * Constructs a new Node object with given data and priority
         * @param data the data
         * @param priority the heap priority
         */
        public Node(E data, int priority) {
            if (data == null) {
                throw new NullPointerException();
            }
            else {
                this.data = data;
                this.priority = priority;
                left = null;
                right = null;
            }
        }

        /**
         * Performs a right rotation according to Figure 2, returning a reference to the root of the result.
         * @return a reference to the root of the result.
         */
        Node<E> rotateLeft() {
            Node<E> right = this.right;
            Node<E> left = right.left;
            right.left = this;
            this.right = left;
            return right;
        }

        /**
         * Performs a left rotation according to Figure 2, returning a reference to the root of the result.
         * @return a reference to the root of the result.
         */
        Node<E> rotateRight() {
            Node<E> left = this.left;
            Node<E> right = left.right;
            left.right = this;
            this.left = right;
            return left;
        }

        /**
         * Overrides toString for Node. It prints the key and the priority.
         * @return the string to be printed
         */
        @Override
        public String toString() {
            return "(key = " + this.data.toString() + ", priority = " + this.priority + ")";
        }
    }

    // The Treap Class

    // Data fields
    private Random priorityGenerator;
    private Node<E> root;


    // Constructors
    /**
     * Creates a new empty Treap. The root will be null, and a new random priority generator is created.
     */
    public Treap() {
        this.root = null;
        this.priorityGenerator = new Random();
    }

    /**
     * Creates a new empty Treap with a null root and a random priority generator based on the seed.
     * @param seed initializes the priorityGenerator
     */
    public Treap(long seed) {
        this.root = null;
        this.priorityGenerator = new Random(seed);
    }

    // Methods

    /**
     * This method will insert a given element into the tree, creating a new node containing key as the
     * data and a random priority generated by priorityGenerator
     * @param key data that will be inserted
     * @return true if successful
     */
    boolean add(E key) {
        return add(key, priorityGenerator.nextInt());
    }

    boolean add(E key, int priority) {
        if(this.root == null) {
            this.root = new Node<>(key, priority);
            return true;
        }

        if(find(key)) {
            return false;
        }

        Stack<Node<E>> stack = new Stack<>();
        Node<E> n = root;

        while(n != null) {
            stack.push(n);
            int compare = n.data.compareTo(key);

            if(compare > 0) {
                if(n.left == null) {
                    n.left = new Node<>(key, priority);
                    reheap(stack, n.left);
                    return true;
                }
                else n = n.left;
            }
            else if (n.right == null) {
                n.right = new Node<>(key, priority);
                reheap(stack, n.right);
                return true;
            } else {
                n = n.right;
            }
        }
        return false;
    }

    public void reheap(Stack<Node<E>> stack, Node<E> current) {
        while(!stack.isEmpty()){
            Node<E> Node = stack.pop();
            int compare = current.data.compareTo(Node.data);

            if(Node.priority > current.priority) {
                break;
            }

            else{
                if(compare > 0) {
                    current = Node.rotateLeft();
                }
                else{
                    current = Node.rotateRight();
                }
            }

            if(!stack.isEmpty()) {
                Node<E> comp = stack.peek();
                if(comp.left == Node) {
                    comp.left = current;
                }
                else{
                    comp.right = current;
                }
            }
            else{
                this.root = current;
            }
        }
    }

    /**
     * Removes the node containing the given key
     * @param key the key which identifies the node to be removed
     * @return true if remove is successful, false otherwise
     */
     boolean delete(E key) {
        if(key == null || !find(key)) {
            return false;
        }
        this.root = delete(this.root, key);
        return true;
    }

    private Node<E> delete(Node<E> current, E key) {
         if(current == null) {
             return null;
         }

         int compare = key.compareTo(current.data);

         if(compare < 0) {
             current.left = delete(current.left, key);
         }
         else if (compare > 0) {
             current.right = delete(current.right, key);
         }
         else{
             if (current.left == null) {
                 return current.right;
             }
             else if(current.right == null) {
                 return current.left;
             }
             else if(current.left.priority < current.right.priority) {
                 current = current.rotateLeft();
                 current.left = delete(current.left, key);
             }
             else{
                 current = current.rotateRight();
                 current.right = delete(current.right, key);
             }
         }
         return current;
    }

    /**
     * Finds a node with the given key in the treap rooted at root and returns true if it finds it and false otherwise.
     * @param root the root
     * @param key the given key to be found
     * @return true if key is found, false otherwise
     */
    private boolean find(Node<E> root, E key) {
        while(root != null) {
            if(key == root.data) {
                return true;
            }
            else if (key.compareTo(root.data) < 0) {
                root = root.left;
            }
            else {
                root = root.right;
            }
        }
        return false;
    }

    /**
     * Finds a node with given key in the treap and returns true if it finds it and false otherwise.
     * @param key the key to be found
     * @return true if key is found, false otherwise
     */
    public boolean find(E key) {
        return find(root, key);
    }

    private String toString(Node<E> current, int l) {
        StringBuilder sb = new StringBuilder();

        for(int i = 0; i < l; i++) {
            sb.append(" ");
        }
        if (current == null) {
            sb.append("null\n");
        }
        else{
            sb.append(current.toString());
            sb.append("\n");
            sb.append(toString(current.left, l + 1));
            sb.append(toString(current.right, l + 1));
        }
        return sb.toString();
    }

    public String toString() {
        return toString(root, 0) + "\n";
    }

    public static void main(String[] args) {
        Treap<Integer> testTree = new Treap<Integer>();
        testTree.add(4, 19);
        testTree.add(2, 31);
        testTree.add(6, 70);
        testTree.add(1, 84);
        testTree.add(3, 12);
        testTree.add(5, 83);
        testTree.add(7,26);
        System.out.println(testTree);
    }

}
